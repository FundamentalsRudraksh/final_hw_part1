calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
e <- eigen(t(G))
v <- Re(e$vectors[,1])
pageranks <- v / sum(v)
return(pageranks)}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
print(P)
calculate_pagerank_power <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(0.5, 0.5, 0,
0.5, 0,   0.5,
1/3, 1/3, 1/3),
nrow = 3, byrow = TRUE)
print(P)
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))
}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
P <- matrix(c(1/2, 1/2, 0,
1/2, 0, 1/2,
1/3, 1/3,1/3),
nrow = 3, byrow = TRUE)
print(P)
# This is my function to find pagerank
calculate_pagerank <- function(P, beta) {
N <- nrow(P)
J <- matrix(1/N, nrow = N, ncol = N)
G <- beta * P + (1 - beta) * J
pi <- rep(1/N, N)
for(i in 1:1000) {
prev_pi <- pi
pi <- pi %*% G}
return(as.vector(pi))
}
# Case1 when Beta = 1
pr_beta_1 <- calculate_pagerank(P, 1)
print("PageRanks for Beta = 1:")
print(pr_beta_1)
# Case2 when Beta = 0.85
pr_beta_085 <- calculate_pagerank(P, 0.85)
print("PageRanks for Beta = 0.85:")
print(pr_beta_085)
# Verify against my result from Q2
manual_calc <- c(6/13, 4/13, 3/13)
print("Result from Q2:")
print(manual_calc)
knitr::opts_chunk$set(echo = TRUE)
# Objective function
g <- function(x, y) {
2*x^2 + y^2 - 2*x*y - 2*x + 2
}
# Gradient of g
grad_g <- function(x, y) {
c(
4*x - 2*y - 2,  # partial derivative w.r.t. x
2*y - 2*x      # partial derivative w.r.t. y
)
}
gradient_descent <- function(x0, y0, alpha = 0.1, tol = 1e-8, max_iter = 10000) {
x <- x0
y <- y0
for (k in 1:max_iter) {
grad <- grad_g(x, y)
# stopping condition
if (sqrt(sum(grad^2)) < tol) {
break
}
# update step
x <- x - alpha * grad[1]
y <- y - alpha * grad[2]
}
list(
x_opt = x,
y_opt = y,
g_value = g(x, y),
iterations = k
)
}
# Example initial point
result <- gradient_descent(x0 = 0, y0 = 0)
result
# Objective function
g <- function(x, y) {
2*x^2 + y^2 - 2*x*y - 2*x + 2
}
# Gradient of g
grad_g <- function(x, y) {
c(
4*x - 2*y - 2,  # partial derivative w.r.t. x
2*y - 2*x      # partial derivative w.r.t. y
)
}
gradient_descent <- function(x0, y0, alpha = 0.1, tol = 1e-8, max_iter = 10000) {
x <- x0
y <- y0
for (k in 1:max_iter) {
grad <- grad_g(x, y)
# stopping condition
if (sqrt(sum(grad^2)) < tol) {
break
}
# update step
x <- x - alpha * grad[1]
y <- y - alpha * grad[2]
}
list(
x_opt = x,
y_opt = y,
g_value = g(x, y),
)
}
# Example initial point
result <- gradient_descent(x0 = 0, y0 = 0)
# Gradient Descent Function in R
gradient_descent <- function(start_x, start_y, learning_rate = 0.1, iterations = 1000) {
# Initialize variables
x <- start_x
y <- start_y
# Create a vector to store the history of the cost function (optional, for tracking)
cost_history <- numeric(iterations)
# Optimization Loop
for(i in 1:iterations) {
# 1. Calculate the gradients
# Derived from: dg/dx = 4x - 2y - 2
grad_x <- 4 * x - 2 * y - 2
# Derived from: dg/dy = 2y - 2x
grad_y <- 2 * y - 2 * x
# 2. Update x and y values
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
# Optional: Calculate current function value to track progress
cost_history[i] <- 2*x^2 + y^2 - 2*x*y - 2*x + 2
}
# Return the final optimized values as a list
return(list(optimized_x = x, optimized_y = y, final_cost = cost_history[iterations]))
}
# --- Main Execution Block ---
# 1. Set your initial values (x0, y0)
x0 <- 0
y0 <- 0
cat("Starting Gradient Descent at x =", x0, ", y =", y0, "\n")
# 2. Run the function
result <- gradient_descent(start_x = x0, start_y = y0)
# 3. Print the results
cat("--------------------------------------\n")
cat("Optimization Complete.\n")
cat(sprintf("Optimized x: %.5f\n", result$optimized_x))
cat(sprintf("Optimized y: %.5f\n", result$optimized_y))
cat(sprintf("Minimum function value: %.5f\n", result$final_cost))
# Gradient Descent Function in R
gradient_descent <- function(start_x, start_y, learning_rate = 0.1, iterations = 1000) {
# Initialize variables
x <- start_x
y <- start_y
# Create a vector to store the history of the cost function (optional, for tracking)
cost_history <- numeric(iterations)
# Optimization Loop
for(i in 1:iterations) {
# 1. Calculate the gradients
# Derived from: dg/dx = 4x - 2y - 2
grad_x <- 4 * x - 2 * y - 2
# Derived from: dg/dy = 2y - 2x
grad_y <- 2 * y - 2 * x
# 2. Update x and y values
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
# Return the final optimized values as a list
return(list(optimized_x = x, optimized_y = y, final_cost = cost_history[iterations]))
}
# --- Main Execution Block ---
# 1. Set your initial values (x0, y0)
x0 <- 0
y0 <- 0
cat("Starting Gradient Descent at x =", x0, ", y =", y0, "\n")
# 2. Run the function
result <- gradient_descent(start_x = x0, start_y = y0)
# 3. Print the results
cat("--------------------------------------\n")
cat("Optimization Complete.\n")
cat(sprintf("Optimized x: %.5f\n", result$optimized_x))
cat(sprintf("Optimized y: %.5f\n", result$optimized_y))
cat(sprintf("Minimum function value: %.5f\n", result$final_cost))
gradient_descent <- function(start_x, start_y, learning_rate = 0.01, iterations = 1000) {
# Initialize variables
x <- start_x
y <- start_y
# Create a vector to store the history of the cost function (optional, for tracking)
cost_history <- numeric(iterations)
# Optimization Loop
for(i in 1:iterations) {
# 1. Calculate the gradients
# Derived from: dg/dx = 4x - 2y - 2
grad_x <- 4 * x - 2 * y - 2
# Derived from: dg/dy = 2y - 2x
grad_y <- 2 * y - 2 * x
# 2. Update x and y values
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
# Return the final optimized values as a list
return(list(optimized_x = x, optimized_y = y, final_cost = cost_history[iterations]))
}
# --- Main Execution Block ---
# 1. Set your initial values (x0, y0)
x0 <- 0
y0 <- 0
cat("Starting Gradient Descent at x =", x0, ", y =", y0, "\n")
# 2. Run the function
result <- gradient_descent(start_x = x0, start_y = y0)
# 3. Print the results
cat("--------------------------------------\n")
cat("Optimization Complete.\n")
cat(sprintf("Optimized x: %.5f\n", result$optimized_x))
cat(sprintf("Optimized y: %.5f\n", result$optimized_y))
cat(sprintf("Minimum function value: %.5f\n", result$final_cost))
gradient_descent <- function(start_x, start_y, learning_rate = 0.01, iterations = 1000) {
x <- start_x
y <- start_y
# Optimization Loop
for(i in 1:iterations) {
# 1. Calculate the gradients
# Derived from: dg/dx = 4x - 2y - 2
grad_x <- 4 * x - 2 * y - 2
# Derived from: dg/dy = 2y - 2x
grad_y <- 2 * y - 2 * x
# 2. Update x and y values
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
# Return the final optimized values as a list
return(list(optimized_x = x, optimized_y = y))
}
# --- Main Execution Block ---
# 1. Set your initial values (x0, y0)
x0 <- 0
y0 <- 0
cat("Starting Gradient Descent at x =", x0, ", y =", y0, "\n")
# 2. Run the function
result <- gradient_descent(start_x = x0, start_y = y0)
# 3. Print the results
cat("--------------------------------------\n")
cat("Optimization Complete.\n")
cat(sprintf("Optimized x: %.5f\n", result$optimized_x))
cat(sprintf("Optimized y: %.5f\n", result$optimized_y))
cat(sprintf("Minimum function value: %.5f\n", result$final_cost))
g <- function(x, y) {2*x^2 + y^2 - 2*x*y - 2*x + 2}
grad_g <- function(x, y) { c(4*x - 2*y - 2, 2*y - 2*x)}
gradient_descent <- function(start_x, start_y, learning_rate = 0.01, iterations = 1000) {
x <- start_x
y <- start_y
for(i in 1:iterations) {
current_gradient <- grad_g(x, y)
grad_x <- current_gradient[1]
grad_y <- current_gradient[2]
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
return(list(optimized_x = x, optimized_y = y))
}
x0 <- 0
y0 <- 0
result <- gradient_descent(start_x = x0, start_y = y0)
cat(sprintf("Optimized x: %.3f\n", result$optimized_x))
cat(sprintf("Optimized y: %.3f\n", result$optimized_y))\
cat(sprintf("Optimized y: %.3f\n", result$optimized_y))
g <- function(x, y) {2*x^2 + y^2 - 2*x*y - 2*x + 2}
grad_g <- function(x, y) { c(4*x - 2*y - 2, 2*y - 2*x)}
gradient_descent <- function(start_x, start_y, learning_rate = 0.01, iterations = 1000) {
x <- start_x
y <- start_y
for(i in 1:iterations) {
current_gradient <- grad_g(x, y)
grad_x <- current_gradient[1]
grad_y <- current_gradient[2]
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
return(list(optimized_x = x, optimized_y = y))
}
x0 <- 0
y0 <- 0
result <- gradient_descent(start_x = x0, start_y = y0)
cat(sprintf("Optimized x: %.3f\n", result$optimized_x))
cat(sprintf("Optimized y: %.3f\n", result$optimized_y))
knitr::opts_chunk$set(echo = TRUE)
g <- function(x, y) {2*x^2 + y^2 - 2*x*y - 2*x + 2}
grad_g <- function(x, y) { c(4*x - 2*y - 2, 2*y - 2*x)}
gradient_descent <- function(start_x, start_y, learning_rate = 0.01, iterations = 1000) {
x <- start_x
y <- start_y
for(i in 1:iterations) {
current_gradient <- grad_g(x, y)
grad_x <- current_gradient[1]
grad_y <- current_gradient[2]
x <- x - (learning_rate * grad_x)
y <- y - (learning_rate * grad_y)
}
return(list(optimized_x = x, optimized_y = y))
}
x0 <- 0
y0 <- 0
result <- gradient_descent(start_x = x0, start_y = y0)
cat(sprintf("Optimized x: %.3f\n", result$optimized_x))
cat(sprintf("Optimized y: %.3f\n", result$optimized_y))
setwd("~/UMass/Grad Files/DACSS-601/final_hw_part1")
knitr::opts_chunk$set(echo = TRUE)
library(rio)
knitr::opts_chunk$set(echo = TRUE)
library(rio)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2006.xlsx"
fsi2006=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2007.xlsx"
fsi2007=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2008.xlsx"
fsi2008=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2009.xlsx"
fsi2009=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2010.xlsx"
fsi2010=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2011.xlsx"
fsi2011=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2012.xlsx"
fsi2012=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2013.xlsx"
fsi2013=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2014.xlsx"
fsi2014=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2015.xlsx"
fsi2015=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2016.xlsx"
fsi2016=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2017.xlsx"
fsi2017=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2018.xlsx"
fsi2018=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2019.xlsx"
fsi2019=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2020.xlsx"
fsi2020=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2021.xlsx"
fsi2021=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2022.xlsx"
fsi2022=rio::import(file = linkGit)
linkGit="https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-2023.xlsx"
fsi2023=rio::import(file = linkGit)
urls <- paste0("https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-", 2006:2023, ".xlsx")
fsi_list <- lapply(urls, rio::import)
View(fsi_list)
fsi_all <- dplyr::bind_rows(fsi_list)
knitr::opts_chunk$set(echo = TRUE)
library(rio)
urls <- paste0("https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-", 2006:2023, ".xlsx")
names(urls) <- paste0("fsi", 2006:2023)
list2env(lapply(urls, rio::import), .GlobalEnv)
View(fsi2016)
View(fsi2022)
View(fsi2016)
View(fsi2016)
View(fsi2020)
keep <- c("Country","Year","Rank","Total","C1:Security:Apparatus","C2:Factionalized Elites","C3:Group Grievance","E1:Economy","E2:Economic Inequality","E3:Human Flight and Brain Drain","P1:State Legitimacy","P2: Public Services","P3: Human Rights","S1: Demographic Pressures","S2:Refugees and IDPs","X1:External Intervention")
fsi_all <- dplyr::select(fsi_all, dplyr::any_of(keep))
fsi_all <- dplyr::bind_rows(lapply(names(urls), get))
library(dplyr)
library(readr)
View(fsi2022)
fix_one <- function(x){
names(x) <- gsub("[ :]+", "_", names(x))
x$Year <- as.integer(readr::parse_number(as.character(x$Year)))
x$Rank <- as.integer(readr::parse_number(as.character(x$Rank)))
x
}
fsi_all <- dplyr::bind_rows(lapply(names(urls), get))
fsi_all <- dplyr::bind_rows(lapply(mget(paste0("fsi", 2006:2023)), fix_one))
keep <- c("Country","Year","Rank","Total","C1_Security_Apparatus","C2_Factionalized_Elites","C3_Group_Grievance","E1_Economy","E2_Economic_Inequality","E3_Human_Flight_and_Brain_Drain","P1_State_Legitimacy","P2_Public_Services","P3_Human_Rights","S1_Demographic_Pressures","S2_Refugees_and_IDPs","X1_External_Intervention")
fsi_all <- dplyr::select(fsi_all, dplyr::any_of(keep))
knitr::opts_chunk$set(echo = TRUE)
library(rio)
library(dplyr)
library(readr)
urls <- paste0("https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-", 2006:2023, ".xlsx")
names(urls) <- paste0("fsi", 2006:2023)
list2env(lapply(urls, rio::import), .GlobalEnv)
fix_one <- function(x){
names(x) <- gsub("[ :]+", "_", names(x))
x$Year <- as.integer(readr::parse_number(as.character(x$Year)))
x$Rank <- as.integer(readr::parse_number(as.character(x$Rank)))
x}
fsi_all <- dplyr::bind_rows(lapply(mget(paste0("fsi", 2006:2023)), fix_one))
keep <- c("Country","Year","Rank","Total","C1_Security_Apparatus","C2_Factionalized_Elites","C3_Group_Grievance","E1_Economy","E2_Economic_Inequality","E3_Human_Flight_and_Brain_Drain","P1_State_Legitimacy","P2_Public_Services","P3_Human_Rights","S1_Demographic_Pressures","S2_Refugees_and_IDPs","X1_External_Intervention")
fsi_all <- dplyr::select(fsi_all, dplyr::any_of(keep))
View(fsi_all)
fsi_all <- dplyr::bind_rows(lapply(names(urls), function(n) fix_one(get(n))))
keep <- c("Country","Year","Rank","Total","C1_Security_Apparatus","C2_Factionalized_Elites","C3_Group_Grievance","E1_Economy","E2_Economic_Inequality","E3_Human_Flight_and_Brain_Drain","P1_State_Legitimacy","P2_Public_Services","P3_Human_Rights","S1_Demographic_Pressures","S2_Refugees_and_IDPs","X1_External_Intervention")
fsi_all <- dplyr::select(fsi_all, dplyr::any_of(keep))
View(fsi_all)
library(ggplot2)
ggplot(fsi_all, aes(x = factor(Year), y = Total)) +
geom_boxplot() +
labs(title="FSI Total score distribution by year", x="Year", y="Total score")
h <- fsi_all %>% dplyr::filter(Year %in% c(2013, 2023)) %>%
tidyr::pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),
names_to="Variable", values_to="Value")
ggplot(h, aes(x = Value)) + geom_histogram(bins = 20) +
facet_grid(Variable ~ Year) +
labs(title="FSI Component distributions: 2013 vs 2023", x="Score", y="Number of countries")
h <- fsi_all %>% dplyr::filter(Year %in% c(2013, 2023)) %>%
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value")
library(tidyr)
h <- fsi_all %>% dplyr::filter(Year %in% c(2013, 2023)) %>%
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value")
ggplot(h, aes(x = Value)) + geom_histogram(bins = 20) +
facet_grid(Variable ~ Year) +
labs(title="FSI Component distributions: 2013 vs 2023", x="Score", y="Number of countries")
h <- fsi_all %>% filter(Year %in% c(2013, 2023)) %>%
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value")
ggplot(h, aes(x = Value)) + geom_histogram(bins = 20) +
facet_grid(Variable ~ Year) +
labs(title="FSI Component distributions: 2013 vs 2023", x="Score", y="Number of countries")
h <- fsi_all %>% filter(Year %>% c(2013, 2023)) %>%
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value")
h <- fsi_all %>% filter(Year %in% c(2013, 2023)) %>%
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value")
ggplot(h, aes(x = Value)) + geom_histogram(bins = 20) +
facet_grid(Variable ~ Year) +
labs(title="FSI Component distributions: 2013 vs 2023", x="Score", y="Number of countries")
class(fsi2023$Year)
class(fsi_all$Year)
class(fsi_all$Rank)
knitr::opts_chunk$set(echo = TRUE)
library(rio) # Load the packages for future use
library(dplyr) # Load the packages for future use
library(readr) # Load the packages for future use
library(ggplot2) # Load the packages for future use
library(tidyr) # Load the packages for future use
urls <- paste0("https://github.com/FundamentalsRudraksh/final_hw_part1/raw/refs/heads/main/fsi-", 2006:2023, ".xlsx") # Load the different urls from github. Used paste0 to combine the different years in the url
names(urls) <- paste0("fsi", 2006:2023) # Assigns names to each url like fsi2006 etc
list2env(lapply(urls, rio::import), .GlobalEnv) # Creates separate data frames for different url
class(fsi2023$Year) # Shows that the Year column in fsi2023 is numeric and not integer
fix_one <- function(x){ # Helper function
names(x) <- gsub("[ :]+", "_", names(x)) # Renames the column by replacing : with _
x$Year <- as.integer(readr::parse_number(as.character(x$Year))) # Converts Year column to integer
x$Rank <- as.integer(readr::parse_number(as.character(x$Rank))) # Removes any extra rank from the Rank column and also converts it into integer
x}
fsi_all <- dplyr::bind_rows(lapply(names(urls), function(n) fix_one(get(n)))) # Applies the helper function and appends all the files vertically
class(fsi_all$Year) # Shows that the Year column is integer after reformatting
class(fsi_all$Rank) # Shows that the Rank column is integer after reformatting
keep <- c("Country","Year","Rank","Total","C1_Security_Apparatus","C2_Factionalized_Elites","C3_Group_Grievance","E1_Economy","E2_Economic_Inequality","E3_Human_Flight_and_Brain_Drain","P1_State_Legitimacy","P2_Public_Services","P3_Human_Rights","S1_Demographic_Pressures","S2_Refugees_and_IDPs","X1_External_Intervention") # Define the set of columns to be used further
fsi_all <- dplyr::select(fsi_all, dplyr::any_of(keep)) # Keeps only the selected columns from keep and removes all the other columns
ggplot(fsi_all, aes(x = factor(Year), y = Total)) +
geom_boxplot() +
labs(title="FSI Total score distribution by year", x="Year", y="Total score") # Creates boxplot of Total FSI scores for each year using ggplot and adds descriptive title and axis names
h <- fsi_all %>% filter(Year %in% c(2013, 2023)) %>% # Keep only 2 years 2013 and 2023
pivot_longer(c(C1_Security_Apparatus, C2_Factionalized_Elites, C3_Group_Grievance),   names_to="Variable", values_to="Value") # Choose only these 3 columns and change them to the long format for plotting
ggplot(h, aes(x = Value)) + geom_histogram(bins = 20) + # Creates histogram which shows distribution of score across countries
facet_grid(Variable ~ Year) + # Separates histogram by the three components and the two years
labs(title="FSI Component distributions: 2013 vs 2023", x="Score", y="Number of countries") # Add descriptive title and axis description
